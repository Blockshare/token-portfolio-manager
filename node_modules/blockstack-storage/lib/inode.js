'use strict';

Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.makeEmptyDeviceRootDirectory = makeEmptyDeviceRootDirectory;
exports.deviceRootSerialize = deviceRootSerialize;
exports.deviceRootInsert = deviceRootInsert;
exports.deviceRootRemove = deviceRootRemove;
exports.makeFileEntry = makeFileEntry;

var _util = require('./util');

var _schemas = require('./schemas');

var _blob = require('./blob');

var _blockstack = require('blockstack');

var assert = require('assert');
var crypto = require('crypto');
var EC = require('elliptic').ec;
var ec = EC('secp256k1');
var Ajv = require('ajv');
var BigInteger = require('bigi');
var bitcoinjs = require('bitcoinjs-lib');

var BLOCKSTACK_STORAGE_PROTO_VERSION = 1;

/*
 * Make an empty directory page.
 *
 * @param datastore_id (string) the datastore ID
 * @param reader_pubkeys (array) the list of reader public keys
 * @param timestamp (int) the number of milliseconds since the epoch
 *
 * Returns a new device root directory page
 */
function makeEmptyDeviceRootDirectory(datastore_id, reader_pubkeys) {
   var timestamp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

   if (!timestamp) {
      timestamp = new Date().getTime();
   }

   var readers = [];
   var _iteratorNormalCompletion = true;
   var _didIteratorError = false;
   var _iteratorError = undefined;

   try {
      for (var _iterator = reader_pubkeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
         var reader_pubk = _step.value;

         readers.push((0, _blockstack.publicKeyToAddress)(reader_pubk));
      }
   } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
   } finally {
      try {
         if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
         }
      } finally {
         if (_didIteratorError) {
            throw _iteratorError;
         }
      }
   }

   var deviceRootDir = {
      'proto_version': 2,
      'type': _schemas.ROOT_DIRECTORY_LEAF,
      'owner': datastore_id,
      'readers': readers,
      'timestamp': timestamp,
      'files': {},
      'tombstones': {}
   };

   return deviceRootDir;
}

/*
 * Serialize a device root to a string.
 *
 * @param device_id (string) this device ID
 * @param datastore_id (string) the ID fo this datastore
 * @param root_uuid (string) the ID of the root directory 
 * @param device_root (object) the device-specific root page
 *
 */
function deviceRootSerialize(device_id, datastore_id, root_uuid, device_root) {
   var data_id = datastore_id + '.' + root_uuid;
   var device_root_data_id = (0, _blockstack.makeFullyQualifiedDataId)(device_id, data_id);
   var device_root_data = JSON.stringify(device_root);
   var device_root_blob = (0, _blob.makeDataInfo)(data_id, device_root_data, device_id, device_root_data_id);
   return device_root_blob;
}

/*
 * Insert a file header into the device root
 *
 * @param datastore_id (string) the datastore ID
 * @param root_uuid (string) the UUID of the root
 * @param device_root (object) the device root page
 * @param file_name (string) the name of this file
 * @param file_entry (object) the file header 
 * @param device_id (string) this device ID
 *
 * Returns {'device_root_blob': ..., 'timestamp': ...}
 */
function deviceRootInsert(datastore_id, root_uuid, device_root, file_name, file_entry, device_id) {
   var now = new Date().getTime();
   var new_timestamp = device_root['timestamp'] + 1 > now ? device_root['timestamp'] + 1 : now;

   device_root['timestamp'] = new_timestamp;
   device_root['files'][file_name] = file_entry;

   var new_root = deviceRootSerialize(device_id, datastore_id, root_uuid, device_root);
   return { 'device_root_blob': new_root, 'timestamp': new_timestamp };
}

/*
 * Insert a tombstone for a file into a device root
 *
 * @param datastore_id (string) the datastore ID
 * @param root_uuid (string) the UUID of the root
 * @param device_root (object) the device root page
 * @param file_name (string) the name of the file
 * @param file_tombstone (string) the (unsigned) tombstone for this file
 * @param device_id (string) the ID of this device
 *
 * Returns a serialized device root page with teh timestamp advanced and the tombstone inserted
 */
function deviceRootRemove(datastore_id, root_uuid, device_root, file_name, file_tombstone, device_id) {
   var now = new Date().getTime();
   var new_timestamp = device_root['timestamp'] + 1 > now ? device_root['timestamp'] + 1 : now;

   device_root['timestamp'] = new_timestamp;
   device_root['tombstones'][file_name] = file_tombstone;

   var new_root = deviceRootSerialize(device_id, datastore_id, root_uuid, device_root);
   return new_root;
}

/* 
 * Make an empty file entry
 *
 * @param data_hash (string) the sha256 of the data
 * @param data_urls (array) a list of URLs where this data can be found
 *
 * Returns an object that conforms to ROOT_DIRECTORY_ENTRY_SCHEMA
 */
function makeFileEntry(data_hash, data_urls) {
   var file_entry = {
      'proto_version': 2,
      'urls': data_urls,
      'data_hash': data_hash,
      'timestamp': new Date().getTime()
   };

   return file_entry;
}