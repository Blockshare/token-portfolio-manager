'use strict';

Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.selectDrivers = selectDrivers;
var SUPPORTED_STORAGE_CLASSES = exports.SUPPORTED_STORAGE_CLASSES = ["read_public", "write_public", "read_private", "write_private", "read_local", "write_local"];
var REPLICATION_STRATEGY_CLASSES = exports.REPLICATION_STRATEGY_CLASSES = {
   'local': new Set(['read_local', 'write_local']),
   'publish': new Set(['read_public', 'write_private']),
   'public': new Set(['read_public', 'write_public']),
   'private': new Set(['read_private', 'write_private'])
};

/*
 * Fulfill a replication strategy using the drivers available to us.
 *
 * replication_strategy (object): a dict that maps strategies (i.e. 'local', 'public', 'private') to integer counts
 * classes (object): this is session.storage.classes (i.e. the driver classification; maps a driver name to its list of classes)
 *
 * Returns the list of drivers to use.
 * Throws on error.
 */
function selectDrivers(replication_strategy, classes) {

   // select defaults from classification and replication strategy
   var driver_sets = []; // driver_sets[i] is the set of drivers that support SUPPORTED_STORAGE_CLASSES[i]
   var driver_classes = {}; // map driver name to set of classes
   var all_drivers = new Set([]); // set of all drivers available to us
   var available_drivers = []; // drivers available to us
   var selected_drivers = []; // drivers compatible with our replication strategy (return value)
   var have_drivers = false; // whether or not we selected drivers that fulfill our replication strategy

   for (var i = 0; i < SUPPORTED_STORAGE_CLASSES.length; i++) {
      var driver_set = new Set(classes[SUPPORTED_STORAGE_CLASSES[i]]);
      driver_sets.push(driver_set);

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
         for (var _iterator = driver_set[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var d = _step.value;

            all_drivers.add(d);
         }
      } catch (err) {
         _didIteratorError = true;
         _iteratorError = err;
      } finally {
         try {
            if (!_iteratorNormalCompletion && _iterator.return) {
               _iterator.return();
            }
         } finally {
            if (_didIteratorError) {
               throw _iteratorError;
            }
         }
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
         for (var _iterator2 = driver_set[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _d = _step2.value;

            console.log("Driver " + _d + " implementes " + SUPPORTED_STORAGE_CLASSES[i]);
            if (driver_classes[_d]) {
               driver_classes[_d].push(SUPPORTED_STORAGE_CLASSES[i]);
            } else {
               driver_classes[_d] = [SUPPORTED_STORAGE_CLASSES[i]];
            }
         }
      } catch (err) {
         _didIteratorError2 = true;
         _iteratorError2 = err;
      } finally {
         try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
               _iterator2.return();
            }
         } finally {
            if (_didIteratorError2) {
               throw _iteratorError2;
            }
         }
      }
   }

   var concern_fulfillment = {};

   var _iteratorNormalCompletion3 = true;
   var _didIteratorError3 = false;
   var _iteratorError3 = undefined;

   try {
      for (var _iterator3 = all_drivers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
         var _d2 = _step3.value;

         var _classes = driver_classes[_d2];

         // a driver fits the replication strategy if all of its
         // classes matches at least one concern (i.e. 'local', 'public')
         var _iteratorNormalCompletion4 = true;
         var _didIteratorError4 = false;
         var _iteratorError4 = undefined;

         try {
            for (var _iterator4 = Object.keys(replication_strategy)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
               var concern = _step4.value;


               var matches = true;
               var _iteratorNormalCompletion5 = true;
               var _didIteratorError5 = false;
               var _iteratorError5 = undefined;

               try {
                  for (var _iterator5 = REPLICATION_STRATEGY_CLASSES[concern][Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                     var dclass = _step5.value;

                     if (!_classes.includes(dclass)) {
                        matches = false;
                        console.log("Driver " + _d2 + " does not fulfill " + concern + ", since it does not address class " + dclass);
                        break;
                     }
                  }
               } catch (err) {
                  _didIteratorError5 = true;
                  _iteratorError5 = err;
               } finally {
                  try {
                     if (!_iteratorNormalCompletion5 && _iterator5.return) {
                        _iterator5.return();
                     }
                  } finally {
                     if (_didIteratorError5) {
                        throw _iteratorError5;
                     }
                  }
               }

               if (matches) {
                  console.log("Driver " + _d2 + " fulfills replication concern " + concern);

                  if (concern_fulfillment[concern]) {
                     concern_fulfillment[concern] += 1;
                  } else {
                     concern_fulfillment[concern] = 1;
                  }

                  if (concern_fulfillment[concern] <= replication_strategy[concern]) {
                     console.log("Select driver " + _d2);
                     selected_drivers.push(_d2);
                  }
               }

               // strategy fulfilled?
               var fulfilled = true;
               var _iteratorNormalCompletion6 = true;
               var _didIteratorError6 = false;
               var _iteratorError6 = undefined;

               try {
                  for (var _iterator6 = Object.keys(replication_strategy)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                     var sclass = _step6.value;
                     var _iteratorNormalCompletion7 = true;
                     var _didIteratorError7 = false;
                     var _iteratorError7 = undefined;

                     try {
                        for (var _iterator7 = Object.keys(replication_strategy[sclass])[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                           var _concern = _step7.value;

                           var count = 0;
                           if (concern_fulfillment[_concern]) {
                              count = concern_fulfillment[_concern];
                           }

                           if (count < replication_strategy[_concern]) {
                              fulfilled = false;
                              break;
                           }
                        }
                     } catch (err) {
                        _didIteratorError7 = true;
                        _iteratorError7 = err;
                     } finally {
                        try {
                           if (!_iteratorNormalCompletion7 && _iterator7.return) {
                              _iterator7.return();
                           }
                        } finally {
                           if (_didIteratorError7) {
                              throw _iteratorError7;
                           }
                        }
                     }

                     if (!fulfilled) {
                        break;
                     }
                  }
               } catch (err) {
                  _didIteratorError6 = true;
                  _iteratorError6 = err;
               } finally {
                  try {
                     if (!_iteratorNormalCompletion6 && _iterator6.return) {
                        _iterator6.return();
                     }
                  } finally {
                     if (_didIteratorError6) {
                        throw _iteratorError6;
                     }
                  }
               }

               if (fulfilled) {
                  have_drivers = true;
                  break;
               }
            }
         } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
         } finally {
            try {
               if (!_iteratorNormalCompletion4 && _iterator4.return) {
                  _iterator4.return();
               }
            } finally {
               if (_didIteratorError4) {
                  throw _iteratorError4;
               }
            }
         }

         if (have_drivers) {
            break;
         }
      }
   } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
   } finally {
      try {
         if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
         }
      } finally {
         if (_didIteratorError3) {
            throw _iteratorError3;
         }
      }
   }

   if (!have_drivers) {
      throw new Error("Unsatisfiable replication strategy");
   }

   return selected_drivers;
}